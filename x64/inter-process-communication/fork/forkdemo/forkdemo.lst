     1                                  ; Name:         forkdemo
     2                                  ; Build:        see makefile
     3                                  ; Run:          ./forkdemo
     4                                  ; Description:  An example of forking two childprocesses.
     5                                  ;               This program is a first attempt to fork two processes and display output to STDOUT in an
     6                                  ;               organized way. This will not work when using in terminals without escape keys to reposition
     7                                  ;               the cursor. If used in such terminals the output will be unpredictable. It's a nice demonstration
     8                                  ;               but better still to find another way to write to STDOUT.
     9                                  ;
    10                                  ;               The parent starts, forks two childprocesses and each of them will repeatedly shows 0 or 1 on screen.
    11                                  ;               Each process will do this with a different interval. The parent has to stop first domenstrating the
    12                                  ;               system call wait4 on all childprocesses. If all childs are terminated the parent terminbates the
    13                                  ;               entire program.
    14                                  ;
    15                                  ; How-to:       start the program with ./forkdemo in a terminal
    16                                  ;               
    17                                  
    18                                  BITS 64
    19                                  
   462                                  [list -]
   463          ******************       warning: using 64 bits syscalls
   464                                          %include "time.inc"
   465                              <1> %ifndef _ASM_TIME_INC_
   466                              <1> %define _ASM_TIME_INC_
   467                              <1> 
   468                              <1> %define CLOCK_REALTIME 0
   469                              <1> 
   470                              <1> STRUC TIMESPEC_STRUC
   471 00000000 <res 00000008>      <1>   .tv_sec:      resq    1
   472 00000008 <res 00000008>      <1>   .tv_nsec:     resq    1
   473                              <1> ENDSTRUC
   474                              <1> 
   475                              <1> STRUC TIMEVAL_STRUC
   476 00000000 <res 00000008>      <1>   .tv_sec:      resq    1               ; seconds
   477 00000008 <res 00000008>      <1>   .tv_usec:     resq    1               ; microseconds
   478                              <1> ENDSTRUC
   479                              <1> 
   480                              <1> STRUC TIMEZONE_STRUC
   481 00000000 <res 00000008>      <1>   .tz_minuteswest:      resq    1               ; minutes west of Greenwich
   482 00000008 <res 00000008>      <1>   .tz_dsttime:          resq    1               ; type of DST correction
   483                              <1> ENDSTRUC
   484                              <1> 
   485                              <1> 
   486                              <1> ; TIMESPEC takes one mandatory parameter %1 which is the name of the data structure.
   487                              <1> ; The second and third refers to secs and nanosecs respectively and aren't mandatory.
   488                              <1> ; When no value is given for seconds and/or nanoseconds they defaults to zero.
   489                              <1> %macro TIMESPEC 1-3 0,0
   490                              <1>     %1:  ISTRUC TIMESPEC_STRUC
   491                              <1>         at  TIMESPEC_STRUC.tv_sec,     dq %2
   492                              <1>         at  TIMESPEC_STRUC.tv_nsec,    dq %3
   493                              <1>     IEND
   494                              <1> 
   495                              <1>     %define %1.tv_sec   %1+TIMESPEC_STRUC.tv_sec
   496                              <1>     %define %1.tv_nsec  %1+TIMESPEC_STRUC.tv_nsec
   497                              <1> %endmacro
   498                              <1> 
   499                              <1> ; TIMEVAL takes one mandatory parameter %1 which is the name of the data structure.
   500                              <1> ; The second and third refers to secs and microsecs respectively and aren't mandatory.
   501                              <1> ; When no value is given for seconds and/or nanoseconds they defaults to zero.
   502                              <1> %macro TIMEVAL 1-3 0,0
   503                              <1>     %1:  ISTRUC TIMEVAL_STRUC
   504                              <1>         at  TIMEVAL_STRUC.tv_sec,     dq %2
   505                              <1>         at  TIMEVAL_STRUC.tv_usec,    dq %3
   506                              <1>     IEND
   507                              <1> 
   508                              <1>     %define %1.tv_sec   %1+TIMEVAL_STRUC.tv_sec
   509                              <1>     %define %1.tv_usec  %1+TIMEVAL_STRUC.tv_usec
   510                              <1> %endmacro
   511                              <1> 
   512                              <1> ; TIMEZONE takes one mandatory parameter %1 which is the name of the data structure.
   513                              <1> ; The second and third refers to minuteswest and dsttime respectively and aren't mandatory.
   514                              <1> ; When no value is given for minuteswest and/or dsttime they defaults to zero.
   515                              <1> %macro TIMEZONE 1-3 0,0
   516                              <1>     %1:  ISTRUC TIMEZONE_STRUC
   517                              <1>         at  TIMEZONE_STRUC.tz_minuteswest,     dq %2
   518                              <1>         at  TIMEZONE_STRUC.tz_dsttime,         dq %3
   519                              <1>     IEND
   520                              <1> 
   521                              <1>     %define %1.tz_minuteswest   %1+TIMEZONE_STRUC.tz_minuteswest
   522                              <1>     %define %1.tz_dsttime       %1+TIMEZONE_STRUC.tz_dsttime
   523                              <1> %endmacro
   524                              <1> 
   525                              <1> %endif
   526                                  
   527                                          STRUC PROCESS_STRUC
   528 00000000 <res 00000008>                    .address:     resq    1
   529 00000008 <res 00000008>                    .PID:         resq    1
   530 00000010 <res 00000001>                    .pidok:       resb    1
   531 00000011 <res 00000008>                    .timer:       resq    1
   532 00000019 <res 00000008>                    .iterations:  resq    1
   533                                          ENDSTRUC
   534                                  
   535                                          %macro PROCESS 5
   536                                            %define %1.address          %1+PROCESS_STRUC.address
   537                                            %define %1.PID              %1+PROCESS_STRUC.PID
   538                                            %define %1.pidok            %1+PROCESS_STRUC.pidok
   539                                            %define %1.timer            %1+PROCESS_STRUC.timer
   540                                            %define %1.iterations       %1+PROCESS_STRUC.iterations
   541                                            
   542                                            TIMESPEC timer%1,%4,%5
   543                                            
   544                                            %1: ISTRUC PROCESS_STRUC
   545                                              at    PROCESS_STRUC.address,    dq %2
   546                                              at    PROCESS_STRUC.PID,        dq 0
   547                                              at    PROCESS_STRUC.pidok,      db 0
   548                                              at    PROCESS_STRUC.timer,      dq timer%1
   549                                              at    PROCESS_STRUC.iterations, dq %3
   550                                            IEND 
   551                                          %endmacro
   552                                  [list +]
   553                                  
   554                                  section .bss
   555                                  
   556                                  section .data
   557                                  
   558 00000000 1B5B481B5B33304328-     sParentWaiting: db 0x1B,"[H",0x1B,"[30C(waiting for childs to finish)",0x1B,"[H"
   559 00000009 77616974696E672066-
   560 00000012 6F72206368696C6473-
   561 0000001B 20746F2066696E6973-
   562 00000024 68291B5B48         
   563                                         .length: equ $-sParentWaiting
   564                                  
   565 00000029 1B5B481B5B33304341-     sAllChildsDone: db 0x1B,"[H",0x1B,"[30CAll childs are done, program terminated.",0x1B,"[H",0x1B,"[3B",0x1B,"[?25h"
   566 00000032 6C6C206368696C6473-
   567 0000003B 2061726520646F6E65-
   568 00000044 2C2070726F6772616D-
   569 0000004D 207465726D696E6174-
   570 00000056 65642E1B5B481B5B33-
   571 0000005F 421B5B3F323568     
   572                                         .length: equ $-sAllChildsDone
   573                                  
   574 00000066 1B5B48506172656E74-     sParent: db 0x1B,"[HParent: [PID: "
   575 0000006F 3A205B5049443A20   
   576 00000077 00<rept>                   .pID: times 20 db 0                         ; space for decimal PID
   577 0000008B 5D20                             db "] "
   578 0000008D 30                      .buffer: db "0"
   579 0000008E 000000                           db 0,0,0                              ; extra bytes for "done" "d" goes in offset .buffer
   580 00000091 1B5B48                           db 0x1B,"[H"
   581                                  .length: equ $-sParent
   582                                  
   583 00000094 1B5B481B5B31424368-     sChild1: db 0x1B,"[H",0x1B,"[1BChild1: [PID: "
   584 0000009D 696C64313A205B5049-
   585 000000A6 443A20             
   586 000000A9 00<rept>                   .pID: times 20 db 0                         ; space for decimal PID
   587 000000BD 5D20                             db  "] "
   588 000000BF 30                      .buffer: db  "0"
   589 000000C0 000000                           db 0,0,0                              ; extra bytes for "done" "d" goes in offset .buffer
   590 000000C3 1B5B48                           db 0x1B,"[H"
   591                                  .length: equ $-sChild1
   592                                  
   593 000000C6 1B5B481B5B32424368-     sChild2: db 0x1B,"[H",0x1B,"[2BChild2: [PID: "
   594 000000CF 696C64323A205B5049-
   595 000000D8 443A20             
   596 000000DB 00<rept>                   .pID: times 20 db 0                         ; space for decimal PID
   597 000000EF 5D20                             db  "] "
   598 000000F1 30                      .buffer: db  "0"
   599 000000F2 000000                           db 0,0,0                              ; extra bytes for "done" "d" goes in offset .buffer
   600 000000F5 1B5B48                           db 0x1B,"[H"
   601                                  .length: equ $-sChild2
   602                                  
   603                                  ; clear screen and hide cursor
   604 000000F8 1B5B481B5B324A1B5B-     sClearScreen: db 0x1B,"[H",0x1B,"[2J",0x1B,"[?25l"
   605 00000101 3F32356C           
   606                                       .length: equ $-sClearScreen
   607                                  
   608                                  ; this error should be more in detail
   609 00000105 416E206572726F7220-      sError: db "An error occured",10
   610 0000010E 6F6363757265640A   
   611                                  .length: equ $-sError
   612                                   
   613                                  ; define process by name, pointer to routine, iterations, seconds, nanoseconds
   614                                  PROCESS Parent,ParentProcess,15,1,0
   615                              <1>  %define %1.address %1+PROCESS_STRUC.address
   616                              <1>  %define %1.PID %1+PROCESS_STRUC.PID
   617                              <1>  %define %1.pidok %1+PROCESS_STRUC.pidok
   618                              <1>  %define %1.timer %1+PROCESS_STRUC.timer
   619                              <1>  %define %1.iterations %1+PROCESS_STRUC.iterations
   620                              <1> 
   621                              <1>  TIMESPEC timer%1,%4,%5
   622                              <2>  %1: ISTRUC TIMESPEC_STRUC
   623 00000116 0100000000000000    <2>  at TIMESPEC_STRUC.tv_sec, dq %2
   624 0000011E 0000000000000000    <2>  at TIMESPEC_STRUC.tv_nsec, dq %3
   625                              <2>  IEND
   626                              <2> 
   627                              <2>  %define %1.tv_sec %1+TIMESPEC_STRUC.tv_sec
   628                              <2>  %define %1.tv_nsec %1+TIMESPEC_STRUC.tv_nsec
   629                              <1> 
   630                              <1>  %1: ISTRUC PROCESS_STRUC
   631 00000126 [6100000000000000]  <1>  at PROCESS_STRUC.address, dq %2
   632 0000012E 0000000000000000    <1>  at PROCESS_STRUC.PID, dq 0
   633 00000136 00                  <1>  at PROCESS_STRUC.pidok, db 0
   634 00000137 [1601000000000000]  <1>  at PROCESS_STRUC.timer, dq timer%1
   635 0000013F 0F00000000000000    <1>  at PROCESS_STRUC.iterations, dq %3
   636                              <1>  IEND
   637                                  PROCESS Child1,Child1Process,21,0,500000000
   638                              <1>  %define %1.address %1+PROCESS_STRUC.address
   639                              <1>  %define %1.PID %1+PROCESS_STRUC.PID
   640                              <1>  %define %1.pidok %1+PROCESS_STRUC.pidok
   641                              <1>  %define %1.timer %1+PROCESS_STRUC.timer
   642                              <1>  %define %1.iterations %1+PROCESS_STRUC.iterations
   643                              <1> 
   644                              <1>  TIMESPEC timer%1,%4,%5
   645                              <2>  %1: ISTRUC TIMESPEC_STRUC
   646 00000147 0000000000000000    <2>  at TIMESPEC_STRUC.tv_sec, dq %2
   647 0000014F 0065CD1D00000000    <2>  at TIMESPEC_STRUC.tv_nsec, dq %3
   648                              <2>  IEND
   649                              <2> 
   650                              <2>  %define %1.tv_sec %1+TIMESPEC_STRUC.tv_sec
   651                              <2>  %define %1.tv_nsec %1+TIMESPEC_STRUC.tv_nsec
   652                              <1> 
   653                              <1>  %1: ISTRUC PROCESS_STRUC
   654 00000157 [1C01000000000000]  <1>  at PROCESS_STRUC.address, dq %2
   655 0000015F 0000000000000000    <1>  at PROCESS_STRUC.PID, dq 0
   656 00000167 00                  <1>  at PROCESS_STRUC.pidok, db 0
   657 00000168 [4701000000000000]  <1>  at PROCESS_STRUC.timer, dq timer%1
   658 00000170 1500000000000000    <1>  at PROCESS_STRUC.iterations, dq %3
   659                              <1>  IEND
   660                                  PROCESS Child2,Child2Process,15,2,0
   661                              <1>  %define %1.address %1+PROCESS_STRUC.address
   662                              <1>  %define %1.PID %1+PROCESS_STRUC.PID
   663                              <1>  %define %1.pidok %1+PROCESS_STRUC.pidok
   664                              <1>  %define %1.timer %1+PROCESS_STRUC.timer
   665                              <1>  %define %1.iterations %1+PROCESS_STRUC.iterations
   666                              <1> 
   667                              <1>  TIMESPEC timer%1,%4,%5
   668                              <2>  %1: ISTRUC TIMESPEC_STRUC
   669 00000178 0200000000000000    <2>  at TIMESPEC_STRUC.tv_sec, dq %2
   670 00000180 0000000000000000    <2>  at TIMESPEC_STRUC.tv_nsec, dq %3
   671                              <2>  IEND
   672                              <2> 
   673                              <2>  %define %1.tv_sec %1+TIMESPEC_STRUC.tv_sec
   674                              <2>  %define %1.tv_nsec %1+TIMESPEC_STRUC.tv_nsec
   675                              <1> 
   676                              <1>  %1: ISTRUC PROCESS_STRUC
   677 00000188 [A301000000000000]  <1>  at PROCESS_STRUC.address, dq %2
   678 00000190 0000000000000000    <1>  at PROCESS_STRUC.PID, dq 0
   679 00000198 00                  <1>  at PROCESS_STRUC.pidok, db 0
   680 00000199 [7801000000000000]  <1>  at PROCESS_STRUC.timer, dq timer%1
   681 000001A1 0F00000000000000    <1>  at PROCESS_STRUC.iterations, dq %3
   682                              <1>  IEND
   683                                    
   684                                  section .text
   685                                          global _start
   686                                  _start:
   687 00000000 48BE-                           mov     rsi, sClearScreen
   688 00000002 [F800000000000000] 
   689 0000000A BA0D000000                      mov     rdx, sClearScreen.length
   690 0000000F E831020000                      call    Write
   691 00000014 B839000000                      mov     rax, SYS_fork
   692 00000019 0F05                            syscall                                     ; invoke fork() get pid in rax
   693 0000001B 50                              push    rax
   694 0000001C 4883F800                        cmp     rax, 0                              ; if pid < 0 then we have an error
   695 00000020 7C26                            jl      .error
   696 00000022 7507                            jnz     .forkChild2                         ; run child1 routine
   697 00000024 FF2425[57010000]                jmp     QWORD[Child1.address]
   698                                  .forkChild2:
   699 0000002B B839000000                      mov     rax, SYS_fork                       ; fork the second child
   700 00000030 0F05                            syscall
   701 00000032 4883F800                        cmp     rax,0                               ; if pid < 0 then we have an error         
   702 00000036 7C10                            jl      .error
   703 00000038 7507                            jnz     .runParent
   704 0000003A FF2425[88010000]                jmp     QWORD[Child2.address]
   705                                  .runParent:
   706 00000041 FF2425[26010000]                jmp     QWORD[Parent.address]               ; run parent routine
   707                                  .error:    
   708 00000048 48BE-                           mov     rsi, sError
   709 0000004A [0501000000000000] 
   710 00000052 BA11000000                      mov     rdx, sError.length
   711 00000057 E8E9010000                      call    Write
   712 0000005C E930020000                      jmp     Exit
   713                                      
   714                                  ; ParentProcess
   715                                  ; This is just example code, the same as for the other two childs.
   716                                  ; If you should change the name of this routine, then change it in the structure too!
   717                                  
   718                                  ParentProcess:
   719 00000061 803C25[36010000]01              cmp     BYTE[Parent.pidok], 1               ; if this value is 1
   720 00000069 7426                            je      .start                              ; then the PID is already calculated
   721 0000006B B827000000                      mov     rax, SYS_getpid                     ; else get PID
   722 00000070 0F05                            syscall
   723 00000072 48890425[2E010000]              mov     QWORD[Parent.PID], rax              ; store PID
   724 0000007A 48BF-                           mov     rdi, sParent.pID                    ; buffer to store decimal PID
   725 0000007C [7700000000000000] 
   726 00000084 E8E0010000                      call    ConvertToDecimal                    ; convert RAX to decimal
   727 00000089 C60425[36010000]01              mov     BYTE[Parent.pidok], 1               ; set flag
   728                                  .start:    
   729 00000091 488B0C25[3F010000]              mov     rcx, QWORD[Parent.iterations]
   730                                  .repeat:
   731 00000099 48BE-                           mov     rsi, sParent
   732 0000009B [6600000000000000] 
   733 000000A3 BA2E000000                      mov     rdx, sParent.length
   734 000000A8 E898010000                      call    Write
   735 000000AD 488B3C25[37010000]              mov     rdi, QWORD[Parent.timer]
   736 000000B5 E89E010000                      call    Sleep
   737 000000BA 803425[8D000000]01              xor     BYTE[sParent.buffer], 1
   738 000000C2 E2D5                            loop    .repeat
   739 000000C4 C70425[8D000000]64-             mov     DWORD[sParent.buffer],"done"
   740 000000CC 6F6E65             
   741 000000CF 48BE-                           mov     rsi, sParent
   742 000000D1 [6600000000000000] 
   743 000000D9 BA2E000000                      mov     rdx, sParent.length
   744 000000DE E862010000                      call    Write       
   745 000000E3 48BE-                           mov     rsi, sParentWaiting
   746 000000E5 [0000000000000000] 
   747 000000ED BA29000000                      mov     rdx, sParentWaiting.length
   748 000000F2 E84E010000                      call    Write
   749 000000F7 B902000000                      mov     rcx, 2
   750                                  .waitForChilds:
   751 000000FC E826010000                      call    WaitForChild                        ; when one has finished wait for the next
   752 00000101 E2F9                            loop    .waitForChilds                       
   753 00000103 48BE-                           mov     rsi, sAllChildsDone                 ; until all childs are done
   754 00000105 [2900000000000000] 
   755 0000010D BA3D000000                      mov     rdx, sAllChildsDone.length
   756 00000112 E82E010000                      call    Write
   757 00000117 E975010000                      jmp     Exit
   758                                  
   759                                  ; Child1Process
   760                                  ; This is just example code, the same as for the other child and the parent process.
   761                                  ; If you should change the name of this routine, then change it in the structure too!
   762                                  
   763                                  Child1Process:
   764 0000011C 803C25[67010000]01              cmp     BYTE[Child1.pidok], 1               ; same as for parent
   765 00000124 7426                            je      .start
   766 00000126 B827000000                      mov     rax, SYS_getpid
   767 0000012B 0F05                            syscall
   768 0000012D 48890425[5F010000]              mov     QWORD[Child1.PID], rax
   769 00000135 48BF-                           mov     rdi, sChild1.pID
   770 00000137 [A900000000000000] 
   771 0000013F E825010000                      call    ConvertToDecimal
   772 00000144 C60425[67010000]01              mov     BYTE[Child1.pidok], 1
   773                                  .start:    
   774 0000014C 488B0C25[70010000]              mov     rcx, QWORD[Child1.iterations]
   775                                  .repeat:
   776 00000154 48BE-                           mov     rsi, sChild1
   777 00000156 [9400000000000000] 
   778 0000015E BA32000000                      mov     rdx, sChild1.length
   779 00000163 E8DD000000                      call    Write
   780 00000168 488B3C25[68010000]              mov     rdi, QWORD[Child1.timer]
   781 00000170 E8E3000000                      call    Sleep
   782 00000175 803425[BF000000]01              xor     BYTE[sChild1.buffer], 1             ; toggle value in buffer
   783 0000017D E2D5                            loop    .repeat
   784 0000017F C70425[BF000000]64-             mov     DWORD[sChild1.buffer],"done"
   785 00000187 6F6E65             
   786 0000018A 48BE-                           mov     rsi, sChild1
   787 0000018C [9400000000000000] 
   788 00000194 BA32000000                      mov     rdx, sChild1.length
   789 00000199 E8A7000000                      call    Write
   790 0000019E E9EE000000                      jmp     Exit
   791                                  
   792                                  
   793                                  ; Child2Process
   794                                  ; This is just example code, the same as for the other child and the parent process.
   795                                  ; If you should change the name of this routine, then change it in the structure too!
   796                                  
   797                                  Child2Process:
   798 000001A3 803C25[98010000]01              cmp     BYTE[Child2.pidok], 1               ; same as for parent
   799 000001AB 7426                            je      .start
   800 000001AD B827000000                      mov     rax, SYS_getpid
   801 000001B2 0F05                            syscall
   802 000001B4 48890425[90010000]              mov     QWORD[Child2.PID], rax
   803 000001BC 48BF-                           mov     rdi, sChild2.pID
   804 000001BE [DB00000000000000] 
   805 000001C6 E89E000000                      call    ConvertToDecimal
   806 000001CB C60425[98010000]01              mov     BYTE[Child2.pidok], 1
   807                                  .start:    
   808 000001D3 488B0C25[A1010000]              mov     rcx, QWORD[Child2.iterations]
   809                                  .repeat:
   810 000001DB 48BE-                           mov     rsi, sChild2
   811 000001DD [C600000000000000] 
   812 000001E5 BA32000000                      mov     rdx, sChild2.length
   813 000001EA E856000000                      call    Write
   814 000001EF 488B3C25[99010000]              mov     rdi, QWORD[Child2.timer]
   815 000001F7 E85C000000                      call    Sleep
   816 000001FC 803425[F1000000]01              xor     BYTE[sChild2.buffer], 1             ; toggle value
   817 00000204 E2D5                            loop    .repeat
   818 00000206 C70425[F1000000]64-             mov     DWORD[sChild2.buffer],"done"
   819 0000020E 6F6E65             
   820 00000211 48BE-                           mov     rsi, sChild2
   821 00000213 [C600000000000000] 
   822 0000021B BA32000000                      mov     rdx, sChild2.length
   823 00000220 E820000000                      call    Write
   824 00000225 EB6A                            jmp     Exit    
   825                                  
   826                                  
   827                                  ; WaitForChild
   828                                  ; Wait for any child that is still running, if any.
   829                                  
   830                                  WaitForChild:
   831 00000227 50                              push    rax
   832 00000228 51                              push    rcx
   833 00000229 52                              push    rdx
   834 0000022A 56                              push    rsi
   835 0000022B 57                              push    rdi
   836 0000022C 4831C9                          xor     rcx, rcx
   837 0000022F 4831F6                          xor     rsi, rsi
   838 00000232 4831FF                          xor     rdi, rdi
   839 00000235 4831D2                          xor     rdx, rdx
   840 00000238 B83D000000                      mov     rax, SYS_wait4                      ; wait for child to terminate
   841 0000023D 0F05                            syscall
   842 0000023F 5F                              pop     rdi
   843 00000240 5E                              pop     rsi
   844 00000241 5A                              pop     rdx
   845 00000242 59                              pop     rcx
   846 00000243 58                              pop     rax
   847 00000244 C3                              ret
   848                                  
   849                                  ; Write
   850                                  ; Writes a string in RSI with length RDX to STDOUT.
   851                                  ; All registers are restored.
   852                                  
   853                                  Write:
   854 00000245 50                              push    rax
   855 00000246 51                              push    rcx
   856 00000247 57                              push    rdi
   857 00000248 BF00000000                      mov     rdi, stdout
   858 0000024D B801000000                      mov     rax, SYS_write
   859 00000252 0F05                            syscall
   860 00000254 5F                              pop     rdi
   861 00000255 59                              pop     rcx
   862 00000256 58                              pop     rax
   863 00000257 C3                              ret
   864                                  
   865                                  ; Sleep:
   866                                  ; RDI contains a pointer to the TIMESPEC structure. Here we don't use the *rem timespec
   867                                  ; structure to store the remaining time. (in RSI).
   868                                  ; All registers are restored.
   869                                  
   870                                  Sleep:
   871 00000258 50                              push    rax
   872 00000259 51                              push    rcx
   873 0000025A 56                              push    rsi
   874 0000025B 4831F6                          xor     rsi, rsi
   875 0000025E B823000000                      mov     rax, SYS_nanosleep
   876 00000263 0F05                            syscall
   877 00000265 5E                              pop     rsi
   878 00000266 59                              pop     rcx
   879 00000267 58                              pop     rax
   880 00000268 C3                              ret
   881                                  
   882                                  ; ConvertToDecimal
   883                                  ; Converts a hexadecimal value in RAX and stores it in the buffer pointed by²² RDI.
   884                                  ; All registers return unchanged except RAX.
   885                                  
   886                                  ConvertToDecimal:
   887 00000269 9C                              pushfq
   888 0000026A 57                              push    rdi
   889 0000026B 50                              push    rax
   890 0000026C 53                              push    rbx
   891 0000026D 52                              push    rdx
   892 0000026E 4883C713                        add     rdi, 19                 ; point to end of buffer
   893 00000272 BB0A000000                      mov     rbx, 10                 ; base 10
   894 00000277 FD                              std
   895                                  .repeat:    
   896 00000278 4831D2                          xor     rdx, rdx
   897 0000027B 48F7FB                          idiv    rbx                     ; RAX = quotient, RDX = remainder
   898 0000027E 4892                            xchg    rax, rdx                ; change quotient and remainder
   899 00000280 0C30                            or      al, 0x30                ; make ASCII
   900 00000282 AA                              stosb
   901 00000283 4892                            xchg    rax, rdx                ; restore quotient
   902 00000285 4883F800                        cmp     rax, 0                  ; calculations left?
   903 00000289 75ED                            jne     .repeat
   904 0000028B 5A                              pop     rdx
   905 0000028C 5B                              pop     rbx
   906 0000028D 58                              pop     rax
   907 0000028E 5F                              pop     rdi
   908 0000028F 9D                              popfq
   909 00000290 C3                              ret
   910                                  
   911                                  Exit:
   912 00000291 4831FF                      xor     rdi, rdi
   913 00000294 B83C000000                  mov     rax, SYS_exit
   914 00000299 0F05                        syscall
