     1                                  ; nlz.asm
     2                                  ; count leading zeros, binary search
     3                                  ;
     4                                  ; Source: Hacker's Delight - 5.3
     5                                   
   403                                  [list -]
   404                                   
   405                                  bits 64
   406                                   
   407                                  section .bss
   408 00000000 <res 00000001>                buffer: resb 1
   409                                   
   410                                  section .data
   411 00000000 20686173206C656164-           message:       db " has leading zero bits.",0x0A
   412 00000009 696E67207A65726F20-
   413 00000012 626974732E0A       
   414                                        .length:       equ $-message
   415                                   
   416                                  section .text
   417                                  global _start
   418                                   
   419                                  _start:
   420                                   
   421 00000000 B8E8030000                    mov     rax, 1000
   422 00000005 E8EC000000                    call    printBinary
   423 0000000A E841000000                    call    nlz
   424 0000000F 50                            push    rax
   425 00000010 48BE-                         mov     rsi, message
   426 00000012 [0000000000000000] 
   427 0000001A BA05000000                    mov     rdx, 5
   428 0000001F E800010000                    call    print
   429 00000024 58                            pop     rax
   430 00000025 E899000000                    call    printDecimal
   431 0000002A 48BE-                         mov     rsi, message
   432 0000002C [0000000000000000] 
   433 00000034 4883C604                      add     rsi, 4
   434 00000038 BA18000000                    mov     rdx, message.length
   435 0000003D 4883EA04                      sub     rdx, 4
   436 00000041 E8DE000000                    call    print
   437 00000046 4831FF                        xor     rdi, rdi
   438 00000049 B83C000000                    mov     rax, SYS_EXIT
   439 0000004E 0F05                          syscall
   440                                   
   441                                  nlz:                                            ; number of leading zero's
   442 00000050 4821C0                        and       rax, rax
   443 00000053 746D                          jz        @done
   444 00000055 4831DB                        xor       rbx, rbx                        ; storage for number of zero bits
   445                                   
   446 00000058 48B900000000FFFFFF-           mov       rcx, 0xFFFFFFFF00000000
   447 00000061 FF                 
   448 00000062 4885C8                        test      rax, rcx
   449 00000065 7508                          jnz       @1
   450 00000067 4883C320                      add       rbx, 32
   451 0000006B 48C1E020                      shl       rax, 32
   452                                  @1:
   453 0000006F 48C1E110                      shl       rcx, 16
   454 00000073 4885C8                        test      rax, rcx
   455 00000076 7508                          jnz       @2
   456 00000078 4883C310                      add       rbx, 16
   457 0000007C 48C1E010                      shl       rax, 16
   458                                  @2:
   459 00000080 48C1E108                      shl       rcx, 8
   460 00000084 4885C8                        test      rax, rcx
   461 00000087 7508                          jnz       @3
   462 00000089 4883C308                      add       rbx, 8
   463 0000008D 48C1E008                      shl       rax, 8
   464                                  @3:
   465 00000091 48C1E104                      shl       rcx, 4
   466 00000095 4885C8                        test      rax, rcx
   467 00000098 7508                          jnz       @4
   468 0000009A 4883C304                      add       rbx, 4
   469 0000009E 48C1E004                      shl       rax, 4
   470                                  @4:
   471 000000A2 48C1E102                      shl       rcx, 2
   472 000000A6 4885C8                        test      rax, rcx
   473 000000A9 7508                          jnz       @5
   474 000000AB 4883C302                      add       rbx, 2
   475 000000AF 48C1E002                      shl       rax, 2
   476                                  @5:
   477 000000B3 48D1E1                        shl       rcx, 1
   478 000000B6 4885C8                        test      rax, rcx
   479 000000B9 7504                          jnz       @6
   480 000000BB 4883C301                      add       rbx, 1
   481                                  @6:
   482 000000BF 4889D8                        mov       rax, rbx                ; result in rax
   483                                  @done:      
   484 000000C2 C3                            ret
   485                                   
   486                                  printDecimal:
   487                                        ; maximum 64 bits in a qword, so we divide first by 10
   488 000000C3 50                            push      rax
   489 000000C4 4831D2                        xor       rdx, rdx
   490 000000C7 BB0A000000                    mov       rbx, 10
   491 000000CC 48F7FB                        idiv      rbx
   492 000000CF 4883F800                      cmp       rax, 0
   493 000000D3 7410                          je        .last
   494 000000D5 0430                          add       al, 0x30                ; make ascii
   495 000000D7 880425[00000000]              mov       BYTE[buffer], al
   496 000000DE 52                            push      rdx
   497 000000DF E831000000                    call      printBuffer
   498 000000E4 5A                            pop       rdx
   499                                  .last:
   500 000000E5 80C230                        add       dl, 0x30                ; make ascii
   501 000000E8 881425[00000000]              mov       BYTE[buffer], dl
   502 000000EF E821000000                    call      printBuffer
   503 000000F4 58                            pop       rax
   504 000000F5 C3                            ret
   505                                   
   506                                  printBinary:
   507 000000F6 50                            push      rax
   508 000000F7 B940000000                    mov       rcx, 64                 ; 64 bits to display
   509 000000FC F8                            clc                               ; clear carry flag
   510                                  .repeat:
   511 000000FD 48D1D0                        rcl       rax, 1                  ; start with leftmost bit
   512 00000100 801425[00000000]30            adc       BYTE[buffer],0x30       ; make it ASCII
   513 00000108 51                            push      rcx
   514 00000109 50                            push      rax
   515 0000010A E806000000                    call      printBuffer
   516 0000010F 58                            pop       rax
   517 00000110 59                            pop       rcx
   518 00000111 E2EA                          loop      .repeat
   519 00000113 58                            pop       rax
   520 00000114 C3                            ret
   521                                   
   522                                  printBuffer:
   523 00000115 48BE-                         mov       rsi, buffer
   524 00000117 [0000000000000000] 
   525 0000011F BA01000000                    mov       rdx, 1
   526                                  print:      
   527 00000124 B801000000                    mov       rax, SYS_WRITE
   528 00000129 BF01000000                    mov       rdi, STDOUT
   529 0000012E 0F05                          syscall
   530 00000130 802425[00000000]00            and       BYTE[buffer],0          ; clear buffer
   531 00000138 C3                            ret
