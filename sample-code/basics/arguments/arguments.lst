     1                                  ; Name:         arguments
     2                                  ;
     3                                  ; Build:        nasm  -felf64 arguments.asm -l arguments.lst -o arguments.o
     4                                  ;               ld -s -melf_x86_64 -o arguments arguments.o 
     5                                  ;
     6                                  ; Description:  Read the number of arguments and if any write it to the STDOUT device.
     7                                  ;
     8                                  ; Remark:
     9                                  ; When a program loads the arguments passed to the program are stored on the stack.
    10                                  ; cfr: C program with argc and argv.
    11                                  ; In assembly language it's easy to get those parameters by popping them from the stack before we do anything else with the stack.
    12                                  ; In more serious programs we should have to deal with the stack adjustment, unless you don't need the arguments anymore. For this
    13                                  ; example we just pop the arguments.
    14                                  ; To preserve some registervalues on stack we need to build a stackframe, push our registervalues on stack and get the argc and argv
    15                                  ; values of the stack.  In this example I don't use a stackframe, just to show how you can get the argc and argv values the easy way.
    16                                  ;
    17                                  ;                   -------------------
    18                                  ; RSP               |     argc + 1    | <-- state of RSP right after program load
    19                                  ;                   |-----------------|
    20                                  ; RSP+8             |   programname   | <-- the programname
    21                                  ;                   |-----------------|
    22                                  ; RSP+16+(n * 8)    |     argv[n]     | <-- pointers to argv[]
    23                                  ;                   |-----------------|
    24                                  ;
    25                                  ; Execution:    ./arguments 10 25 "hello" test12 'test' ?
    26                                  ;
    27                                  ; Output:
    28                                  ; argc        : 7
    29                                  ; programname : ./arguments
    30                                  ; argv[]      : 10 25 hello test12 test ?
    31                                  
    32                                  
    33                                  bits 64
    34                                  
    35                                  [list -]
    38                                  
    39                                       crlf:      equ  10
    40                                  
    41                                  section .bss
    42                                  
    43 00000000 <res 00000014>               buffer:    resb 20                       ; reserve 20 bytes as a buffer
    44                                          
    45                                  section .data
    46                                          
    47 00000000 617267632020202020-          msgArgc:   db   "argc        : ",0
    47 00000009 2020203A2000       
    48 0000000F 50726F6772616D6E61-          msgProg:   db   "Programname : ",0
    48 00000018 6D65203A2000       
    49 0000001E 617267765B5D202020-          msgArgv:   db   "argv[]      : ",0
    49 00000027 2020203A2000       
    50                                          
    51                                  section .text
    52                                          global _start
    53                                  _start:
    54                                       ; write message and argc as unsigned integer to STDOUT
    55 00000000 48BE-                        mov       rsi, msgArgc                  ; write first line
    55 00000002 [0000000000000000] 
    56 0000000A E86F000000                   call      Write.string
    57                                  
    58                                       ; convert the value of argc in unsigned integer ASCII
    59 0000000F 58                           pop       rax                           ; get argc of stack
    60 00000010 48FFC8                       dec       rax                           ; number of arguments is rax minus one
    61 00000013 4889C1                       mov       rcx, rax                      ; initialize RCX as counter (argc)
    62 00000016 E8AA000000                   call      Convert                       ; convert RAX into unsigned integer ASCII
    63 0000001B E85E000000                   call      Write.string                  ; write the unsigned integer
    64                                  
    65 00000020 B00A                         mov       al,crlf                       ; end of line
    66 00000022 E864000000                   call      Write.char
    67                                  
    68                                       ; write message and the programname to STDOUT
    69 00000027 48BE-                        mov       rsi, msgProg                  ; write second line
    69 00000029 [0F00000000000000] 
    70 00000031 E848000000                   call      Write.string       
    71 00000036 5E                           pop       rsi                           ; get programname from stack
    72 00000037 E842000000                   call      Write.string                  ; write the programname
    73 0000003C B00A                         mov       al,crlf                       ; end of line
    74 0000003E E848000000                   call      Write.char
    75                                       ; write message and all arguments to STDOUT
    76 00000043 48BE-                        mov       rsi, msgArgv
    76 00000045 [1E00000000000000] 
    77 0000004D E82C000000                   call      Write.string
    78 00000052 4883F900                     cmp       rcx, 0                        ; are there arguments?
    79 00000056 7415                         je        .endOfArgs                    ; no arguments, nothing to show
    80                                  .nextArg:
    81 00000058 5E                           pop       rsi
    82 00000059 E820000000                   call      Write.string
    83 0000005E 4883F901                     cmp       rcx,1
    84 00000062 7409                         je        .endOfArgs
    85 00000064 B020                         mov       al,' '
    86 00000066 E820000000                   call      Write.char
    87                                  .noSpace:       
    88 0000006B E2EB                         loop      .nextArg
    89                                  
    90                                  .endOfArgs:     
    91 0000006D B00A                         mov       al,crlf
    92 0000006F E817000000                   call      Write.char
    93                                  Exit:
    94 00000074 4831FFB83C0000000F-          syscall    exit, 0
    94 0000007D 05                 
    95                                  
    96                                  Write:
    97                                  .string:
    98 0000007E FC                           cld                                     ; make sure we count upwards in memory
    99 0000007F AC                           lodsb                                   ; load byte from RSI:RAX in AL
   100 00000080 3C00                         cmp       al, 0                         ; if zero then end of ASCIIZ string
   101 00000082 7440                         je        .done
   102 00000084 E802000000                   call      Write.char
   103 00000089 EBF3                         jmp       .string
   104                                  .char:
   105 0000008B 56                           push      rsi
   106 0000008C 51                           push      rcx
   107 0000008D 48BE-                        mov       rsi,buffer
   107 0000008F [0000000000000000] 
   108 00000097 880425[00000000]             mov       byte [buffer],al
   109 0000009E BA0100000048BE-              syscall   write, stdout, buffer, 1
   109 000000A5 [0000000000000000]-
   109 000000AD BF01000000B8010000-
   109 000000B6 000F05             
   110 000000B9 4883F201                     xor       rdx, 1
   111 000000BD 7505                         jnz       .done
   112 000000BF C60600                       mov       byte[rsi],0
   113 000000C2 59                           pop       rcx
   114 000000C3 5E                           pop       rsi                           ; restore used registers
   115                                  .done:
   116 000000C4 C3                           ret
   117                                  
   118                                  Convert:
   119 000000C5 48BE-                        mov       rsi,buffer+19
   119 000000C7 [1300000000000000] 
   120 000000CF BB0A000000                   mov       rbx,10
   121                                  .repeat:
   122 000000D4 4831D2                       xor       rdx,rdx                       ; the remainder
   123 000000D7 48F7F3                       div       rbx                           ; divide RAX by 10, remainder in RDX
   124 000000DA 80CA30                       or        dl,0x30                       ; convert to ASCII
   125 000000DD 8816                         mov       byte[rsi],dl                  ; remainder in byte pointed to by RSI
   126 000000DF 4821C0                       and       rax, rax                      ; quotient = 0? 
   127 000000E2 7405                         je        .done                         ; yes, stop converting
   128 000000E4 48FFCE                       dec       rsi
   129 000000E7 EBEB                         jmp       .repeat
   130                                  .done:
   131 000000E9 C3                           ret
