     1                                  ; Name:         libhello.asm
     2                                  ;
     3                                  ; Build:        nasm -felf64 -o libhello.o libhello.asm -l libhello.lst
     4                                  ;               ld -lc --dynamic-linker /lib64/ld-linux-x86-64.so.2 -shared -soname libhello.so -o libhello.so.1.0 libhello.o
     5                                  ;
     6                                  ; Description:	A "simple" shared library to use with hello.asm
     7                                  ;
     8                                  ; Remark:
     9                                  ; My conclusion is that there is no such thing as an easy way to create shared libraries.
    10                                  ; At least not when you are a true beginner.
    11                                  ; Looking at the programcode you will understand why dynamic libraries aren't a good option to improve speed.
    12                                  ; My general rule is: I don't make shared libraries unless it is really needed.
    13                                  ;
    14                                  ; Also it is wise to keep the ABI in consideration when you want to use shared libraries in your C (C++) programs.
    15                                  ; This is NOT being done in this example.
    16                                  
    17                                  bits 64
    18                                  align 16
    19                                  
    20                                  [list -]
    23                                  
    24                                  
    25                                      extern  _GLOBAL_OFFSET_TABLE_
    26                                  
    27                                  ; five macros to make life a bit easier
    28                                  ; each global function/method/routine (whatever you call it) must start with the PROLOGUE
    29                                  %macro PROLOGUE 0
    30                                          push      rbp 
    31                                          mov       rbp,rsp 
    32                                          push      rbx 
    33                                          call      .get_GOT 
    34                                      .get_GOT: 
    35                                          pop       rbx 
    36                                          add       rbx,_GLOBAL_OFFSET_TABLE_+$$-.get_GOT wrt ..gotpc 
    37                                  %endmacro
    38                                  
    39                                  ; each global function/method/routine (whatever you call it) must end with the EPILOGUE
    40                                  %macro EPILOGUE 0
    41                                          mov       rbx,[rbp-8] 
    42                                          mov       rsp,rbp 
    43                                          pop       rbp 
    44                                          ret
    45                                  %endmacro
    46                                  
    47                                  ; macro to initiate and export the global procedure while defining it as a PROCEDURE
    48                                  ; doing so it's harder to forget to export it
    49                                  %macro PROCEDURE 1
    50                                      global    %1:function
    51                                      %1:
    52                                          PROLOGUE
    53                                  %endmacro
    54                                  
    55                                  ; macro to end the procedure
    56                                  %macro ENDP 1
    57                                          EPILOGUE
    58                                  %endmacro    
    59                                  
    60                                  ; self defined macro to declare global data and export it the same time
    61                                  %macro GLOBALDATA 3
    62                                      global    %1:data (%1.end - %1)
    63                                      section   .data
    64                                          %1:	%2	%3
    65                                          %1.end:
    66                                  %endmacro
    67                                  
    68                                  ; data section
    69                                  
    70                                  GLOBALDATA	 hellostring,db,{"hello from the library...", 10}
    70                              <1>  global %1:data (%1.end - %1)
    70                              <1>  section .data
    70 00000000 68656C6C6F2066726F- <1>  %1: %2 %3
    70 00000009 6D20746865206C6962- <1>
    70 00000012 726172792E2E2E0A    <1>
    70                              <1>  %1.end:
    71                                  GLOBALDATA   hellostring.length,dq,hellostring.end-hellostring
    71                              <1>  global %1:data (%1.end - %1)
    71                              <1>  section .data
    71 0000001A 1A00000000000000    <1>  %1: %2 %3
    71                              <1>  %1.end:
    72                                  GLOBALDATA	 hellostring.pointer,dq,hellostring
    72                              <1>  global %1:data (%1.end - %1)
    72                              <1>  section .data
    72 00000022 [0000000000000000]  <1>  %1: %2 %3
    72                              <1>  %1.end:
    73                                  
    74                                  ; code section
    75                                  
    76                                  section .text
    77                                  
    78                                  _start:
    79                                  
    80                                      PROCEDURE WriteInternalString
    80                              <1>  global %1:function
    80                              <1>  %1:
    80                              <1>  PROLOGUE
    80 00000000 55                  <2>  push rbp
    80 00000001 4889E5              <2>  mov rbp,rsp
    80 00000004 53                  <2>  push rbx
    80 00000005 E800000000          <2>  call .get_GOT
    80                              <2>  .get_GOT:
    80 0000000A 5B                  <2>  pop rbx
    80 0000000B 4881C3[F6FFFFFF]    <2>  add rbx,_GLOBAL_OFFSET_TABLE_+$$-.get_GOT wrt ..gotpc
    81 00000012 E83C000000                      call     GetString
    82                                          ; offset and length of message already in rsi, rdx
    83 00000017 BF01000000B8010000-             syscall write, stdout, rsi, rdx
    83 00000020 000F05             
    84                                      ENDP WriteInternalString
    84                              <1>  EPILOGUE
    84 00000023 488B5DF8            <2>  mov rbx,[rbp-8]
    84 00000027 4889EC              <2>  mov rsp,rbp
    84 0000002A 5D                  <2>  pop rbp
    84 0000002B C3                  <2>  ret
    85                                  
    86                                      ; this procedure has RSI, RDX set to the string and his length we want to print
    87                                      PROCEDURE WriteExternalString
    87                              <1>  global %1:function
    87                              <1>  %1:
    87                              <1>  PROLOGUE
    87 0000002C 55                  <2>  push rbp
    87 0000002D 4889E5              <2>  mov rbp,rsp
    87 00000030 53                  <2>  push rbx
    87 00000031 E800000000          <2>  call .get_GOT
    87                              <2>  .get_GOT:
    87 00000036 5B                  <2>  pop rbx
    87 00000037 4881C3[CAFFFFFF]    <2>  add rbx,_GLOBAL_OFFSET_TABLE_+$$-.get_GOT wrt ..gotpc
    88                                          ; offset and length of message already in rsi, rdx
    89 0000003E BF01000000B8010000-             syscall write, stdout, rsi, rdx
    89 00000047 000F05             
    90                                      ENDP WriteExternalString
    90                              <1>  EPILOGUE
    90 0000004A 488B5DF8            <2>  mov rbx,[rbp-8]
    90 0000004E 4889EC              <2>  mov rsp,rbp
    90 00000051 5D                  <2>  pop rbp
    90 00000052 C3                  <2>  ret
    91                                  
    92                                      ; get the pointer to the libary string and his length
    93                                      PROCEDURE GetString
    93                              <1>  global %1:function
    93                              <1>  %1:
    93                              <1>  PROLOGUE
    93 00000053 55                  <2>  push rbp
    93 00000054 4889E5              <2>  mov rbp,rsp
    93 00000057 53                  <2>  push rbx
    93 00000058 E800000000          <2>  call .get_GOT
    93                              <2>  .get_GOT:
    93 0000005D 5B                  <2>  pop rbx
    93 0000005E 4881C3[A3FFFFFF]    <2>  add rbx,_GLOBAL_OFFSET_TABLE_+$$-.get_GOT wrt ..gotpc
    94 00000065 E815000000                      call    GetStringPointer
    95 0000006A 4889F0                          mov     rax, rsi                 ; move pointer to stringpointer in RAX
    96 0000006D 488B30                          mov     rsi, [rax]               ; move stringpointer in RSI
    97 00000070 4889D0                          mov 	rax, rdx
    98 00000073 488B10                          mov 	rdx, [rax]       
    99                                      ENDP GetString
    99                              <1>  EPILOGUE
    99 00000076 488B5DF8            <2>  mov rbx,[rbp-8]
    99 0000007A 4889EC              <2>  mov rsp,rbp
    99 0000007D 5D                  <2>  pop rbp
    99 0000007E C3                  <2>  ret
   100                                  
   101                                      ; set pointer to string and length of string
   102                                      PROCEDURE GetStringPointer
   102                              <1>  global %1:function
   102                              <1>  %1:
   102                              <1>  PROLOGUE
   102 0000007F 55                  <2>  push rbp
   102 00000080 4889E5              <2>  mov rbp,rsp
   102 00000083 53                  <2>  push rbx
   102 00000084 E800000000          <2>  call .get_GOT
   102                              <2>  .get_GOT:
   102 00000089 5B                  <2>  pop rbx
   102 0000008A 4881C3[77FFFFFF]    <2>  add rbx,_GLOBAL_OFFSET_TABLE_+$$-.get_GOT wrt ..gotpc
   103 00000091 488BB3[22000000]                mov 	rsi, qword [rbx + hellostring.pointer wrt ..got]
   104 00000098 488B93[1A000000]                mov 	rdx, qword [rbx + hellostring.length wrt ..got]
   105                                      ENDP GetStringPointer
   105                              <1>  EPILOGUE
   105 0000009F 488B5DF8            <2>  mov rbx,[rbp-8]
   105 000000A3 4889EC              <2>  mov rsp,rbp
   105 000000A6 5D                  <2>  pop rbp
   105 000000A7 C3                  <2>  ret
   106                                  
   107                                      ; set pointer to string and length of string
   108                                      PROCEDURE SetStringPointer
   108                              <1>  global %1:function
   108                              <1>  %1:
   108                              <1>  PROLOGUE
   108 000000A8 55                  <2>  push rbp
   108 000000A9 4889E5              <2>  mov rbp,rsp
   108 000000AC 53                  <2>  push rbx
   108 000000AD E800000000          <2>  call .get_GOT
   108                              <2>  .get_GOT:
   108 000000B2 5B                  <2>  pop rbx
   108 000000B3 4881C3[4EFFFFFF]    <2>  add rbx,_GLOBAL_OFFSET_TABLE_+$$-.get_GOT wrt ..gotpc
   109 000000BA 4889B3[22000000]                mov 	qword [rbx + hellostring.pointer wrt ..got], rsi
   110 000000C1 488993[1A000000]                mov 	qword [rbx + hellostring.length wrt ..got], rdx
   111                                      ENDP SetStringPointer
   111                              <1>  EPILOGUE
   111 000000C8 488B5DF8            <2>  mov rbx,[rbp-8]
   111 000000CC 4889EC              <2>  mov rsp,rbp
   111 000000CF 5D                  <2>  pop rbp
   111 000000D0 C3                  <2>  ret
   112                                  
   113                                      ; next code is NOT the same as in SetStringPointer.
   114                                      ; Here we modify the stringpointer directly by obtaining the address to it in RAX and put the stringpointer in that location.
   115                                      ; example of indirect addressing
   116                                      PROCEDURE SetString
   116                              <1>  global %1:function
   116                              <1>  %1:
   116                              <1>  PROLOGUE
   116 000000D1 55                  <2>  push rbp
   116 000000D2 4889E5              <2>  mov rbp,rsp
   116 000000D5 53                  <2>  push rbx
   116 000000D6 E800000000          <2>  call .get_GOT
   116                              <2>  .get_GOT:
   116 000000DB 5B                  <2>  pop rbx
   116 000000DC 4881C3[25FFFFFF]    <2>  add rbx,_GLOBAL_OFFSET_TABLE_+$$-.get_GOT wrt ..gotpc
   117 000000E3 488B83[22000000]                mov     rax, qword [rbx + hellostring.pointer wrt ..got]
   118 000000EA 488930                          mov 	[rax], rsi
   119                                          ; same as for the lengtgh of the string      
   120 000000ED 488B83[1A000000]                mov 	rax, qword [rbx + hellostring.length wrt ..got]
   121 000000F4 488910                          mov 	[rax], rdx
   122                                      ENDP SetString
   122                              <1>  EPILOGUE
   122 000000F7 488B5DF8            <2>  mov rbx,[rbp-8]
   122 000000FB 4889EC              <2>  mov rsp,rbp
   122 000000FE 5D                  <2>  pop rbp
   122 000000FF C3                  <2>  ret
