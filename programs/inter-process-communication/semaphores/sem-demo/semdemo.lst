     1                                  bits 64
     2                                  
  1382                                  [list -]
  1383          ******************       warning: using 64 bits syscalls
  1384                                  
  1385                                  STRUC SEM_UNION_STRUC
  1386 00000000 <res 00000008>              .val:       resq    1
  1387 00000008 <res 00000008>              .buf:       resq    1
  1388 00000010 <res 00000008>              .array:     resq    1
  1389                                  ENDSTRUC
  1390                                  
  1391                                  %macro SEM_UNION 1
  1392                                            %1: 
  1393                                            ISTRUC SEM_UNION_STRUC
  1394                                            at    SEM_UNION_STRUC.val,       dq  0
  1395                                            at    SEM_UNION_STRUC.buf,       dq  0
  1396                                            at    SEM_UNION_STRUC.array,     dq  0
  1397                                            IENDS
  1398                                  %endmacro
  1399                                  
  1400                                  
  1401                                  %define MAX_RETRIES 10
  1402                                  
  1403                                  section .bss
  1404 00000000 <res 00000001>               keybuffer:     resb     1
  1405                                  
  1406                                  section .data
  1407                                  
  1408                                       STAT       stat
  1409                              <1>  %1:
  1410                              <1>  ISTRUC STAT_STRUC
  1411 00000000 0000000000000000    <1>  at STAT_STRUC.st_dev, dq 0
  1412 00000008 0000000000000000    <1>  at STAT_STRUC.st_ino, dq 0
  1413 00000010 0000000000000000    <1>  at STAT_STRUC.st_nlink, dq 0
  1414 00000018 00000000            <1>  at STAT_STRUC.st_mod, dd 0
  1415 0000001C 00000000            <1>  at STAT_STRUC.st_uid, dd 0
  1416 00000020 00000000            <1>  at STAT_STRUC.st_gid, dd 0
  1417 00000024 0000000000000000    <1>  at STAT_STRUC.st_rdev, dq 0
  1418 0000002C 00000000            <1>  at STAT_STRUC._pad1, dd 0
  1419 00000030 0000000000000000    <1>  at STAT_STRUC.st_size, dq 0
  1420 00000038 00000000            <1>  at STAT_STRUC.st_blksize, dd 0
  1421 0000003C 00000000            <1>  at STAT_STRUC._pad2, dd 0
  1422 00000040 0000000000000000    <1>  at STAT_STRUC.st_blocks, dq 0
  1423 00000048 0000000000000000    <1>  at STAT_STRUC.st_atime, dq 0
  1424 00000050 0000000000000000    <1>  at STAT_STRUC.st_atime_nsec, dq 0
  1425 00000058 0000000000000000    <1>  at STAT_STRUC.st_mtime, dq 0
  1426 00000060 0000000000000000    <1>  at STAT_STRUC.st_mtime_nsec, dq 0
  1427 00000068 0000000000000000    <1>  at STAT_STRUC.st_ctime, dq 0
  1428 00000070 0000000000000000    <1>  at STAT_STRUC.st_ctime_nsec, dq 0
  1429 00000078 0000000000000000    <1>  at STAT_STRUC._unused1, dq 0
  1430 00000080 0000000000000000    <1>  at STAT_STRUC._unused2, dq 0
  1431 00000088 0000000000000000    <1>  at STAT_STRUC._unused3, dq 0
  1432                              <1>  IEND
  1433                              <1> 
  1434                              <1> 
  1435                              <1> 
  1436                              <1>  %define %1.st_dev %1+STAT_STRUC.st_dev
  1437                              <1>  %define %1.st_ino %1+STAT_STRUC.st_ino
  1438                              <1>  %define %1.st_nlink %1+STAT_STRUC.st_nlink
  1439                              <1>  %define %1.st_mod %1+STAT_STRUC.st_mod
  1440                              <1>  %define %1.st_uid %1+STAT_STRUC.st_uid
  1441                              <1>  %define %1.st_gid %1+STAT_STRUC.st_gid
  1442                              <1>  %define %1.st_rdev %1+STAT_STRUC.st_rdev
  1443                              <1> 
  1444                              <1>  %define %1.st_size %1+STAT_STRUC.st_size
  1445                              <1>  %define %1.st_blksize %1+STAT_STRUC.st_blksize
  1446                              <1> 
  1447                              <1>  %define %1.st_blocks %1+STAT_STRUC.st_blocks
  1448                              <1>  %define %1.st_atime %1+STAT_STRUC.st_atime
  1449                              <1>  %define %1.st_atime_nsec %1+STAT_STRUC.st_atime_nsec
  1450                              <1>  %define %1.st_mtime %1+STAT_STRUC.st_mtime
  1451                              <1>  %define %1.st_mtime_nsec %1+STAT_STRUC.st_mtime_nsec
  1452                              <1>  %define %1.st_ctime %1+STAT_STRUC.st_ctime
  1453                              <1>  %define %1.st_ctime_nsec %1+STAT_STRUC.st_ctime_nsec
  1454                              <1> 
  1455                              <1> 
  1456                              <1> 
  1457                                       TERMIOS    termios
  1458                              <1>  %1: ISTRUC TERMIOS_STRUC
  1459 00000090 00000000            <1>  at TERMIOS_STRUC.c_iflag, dd 0
  1460 00000094 00000000            <1>  at TERMIOS_STRUC.c_oflag, dd 0
  1461 00000098 00000000            <1>  at TERMIOS_STRUC.c_cflag, dd 0
  1462 0000009C 00000000            <1>  at TERMIOS_STRUC.c_lflag, dd 0
  1463 000000A0 00                  <1>  at TERMIOS_STRUC.c_line, db 0
  1464 000000A1 00<rept>            <1>  at TERMIOS_STRUC.c_cc, times 19 db 0
  1465                              <1>  IEND
  1466                              <1>  %define %1.c_iflag %1+TERMIOS_STRUC.c_iflag
  1467                              <1>  %define %1.c_oflag %1+TERMIOS_STRUC.c_oflag
  1468                              <1>  %define %1.c_cflag %1+TERMIOS_STRUC.c_cflag
  1469                              <1>  %define %1.c_lflag %1+TERMIOS_STRUC.c_lflag
  1470                              <1>  %define %1.c_line %1+TERMIOS_STRUC.c_line
  1471                              <1>  %define %1.c_cc %1+TERMIOS_STRUC.c_cc
  1472                                       SEMBUF     sb
  1473                              <1>  %1:
  1474                              <1>  ISTRUC SEMBUF_STRUC
  1475 000000B4 0000000000000000    <1>  at SEMBUF_STRUC.sem_num, dq 0
  1476 000000BC 0000000000000000    <1>  at SEMBUF_STRUC.sem_op, dq 0
  1477 000000C4 0000000000000000    <1>  at SEMBUF_STRUC.sem_flg, dq 0
  1478                              <1>  IEND
  1479                              <1> 
  1480                              <1>  %define %1.sem_num %1+SEMBUF_STRUC.sem_num
  1481                              <1>  %define %1.sem_op %1+SEMBUF_STRUC.sem_op
  1482                              <1>  %define %1.sem_flg %1+SEMBUF_STRUC.sem_flg
  1483                                       SEMID      buf
  1484                              <1>  %1:
  1485                              <1>  ISTRUC SEMID_STRUC
  1486 000000CC 0000000000000000    <1>  at SEMID_STRUC.sem_perm, dq 0
  1487 000000D4 0000000000000000    <1>  at SEMID_STRUC.sem_otime, dq 0
  1488 000000DC 0000000000000000    <1>  at SEMID_STRUC.__glibc_reserved1, dq 0
  1489 000000E4 0000000000000000    <1>  at SEMID_STRUC.sem_ctime, dq 0
  1490 000000EC 0000000000000000    <1>  at SEMID_STRUC.__glibc_reserved2, dq 0
  1491 000000F4 00000000            <1>  at SEMID_STRUC.sem_nsems, dd 0
  1492 000000F8 00<rept>0000000000- <1>  at SEMID_STRUC.__glibc_reserved3, dq 0
  1493 00000101 000000              <1>
  1494 00000104 0000000000000000    <1>  at SEMID_STRUC.__glibc_reserved4, dq 0
  1495                              <1>  IEND
  1496                              <1> 
  1497                              <1> 
  1498                              <1> 
  1499                              <1> 
  1500                              <1>  %define %1.perm %1+SEMID_STRUC.sem_perm
  1501                              <1>  %define %1.perm.uid %1+SEMID_STRUC.sem_perm+IPC_PERM_STRUC.uid
  1502                              <1>  %define %1.perm.gid %1+SEMID_STRUC.sem_perm+IPC_PERM_STRUC.gid
  1503                              <1>  %define %1.perm.cuid %1+SEMID_STRUC.sem_perm+IPC_PERM_STRUC.cuid
  1504                              <1>  %define %1.perm.cgid %1+SEMID_STRUC.sem_perm+IPC_PERM_STRUC.cgid
  1505                              <1>  %define %1.perm.mode %1+SEMID_STRUC.sem_perm+IPC_PERM_STRUC.mode
  1506                              <1>  %define %1.perm.__seq %1+SEMID_STRUC.sem_perm+IPC_PERM_STRUC.__seq
  1507                              <1> 
  1508                              <1>  %define %1.sem_otime %1+SEMID_STRUC.sem_otime
  1509                              <1> 
  1510                              <1>  %define %1.sem_ctime %1+SEMID_STRUC.sem_ctime
  1511                              <1> 
  1512                              <1>  %define %1.sem_nsems %1+SEMID_STRUC.sem_nsems
  1513                              <1> 
  1514                              <1> 
  1515                              <1> 
  1516                                       SEM_UNION  semun
  1517                              <1>  %1:
  1518                              <1>  ISTRUC SEM_UNION_STRUC
  1519 0000010C 0000000000000000    <1>  at SEM_UNION_STRUC.val, dq 0
  1520 00000114 0000000000000000    <1>  at SEM_UNION_STRUC.buf, dq 0
  1521 0000011C 0000000000000000    <1>  at SEM_UNION_STRUC.array, dq 0
  1522                              <1>  IENDS
  1523                                       
  1524                                       
  1525 00000124 0000000000000000             key:           dq        0
  1526 0000012C 0000000000000000             semid:         dq        0
  1527 00000134 2E2F73656D64656D6F-          file:          db        "./semdemo", 0
  1528 0000013D 00                 
  1529                                       
  1530 0000013E 63616E6E6F74206765-          semgeterror:   db   "cannot get semaphore.", 10
  1531 00000147 742073656D6170686F-
  1532 00000150 72652E0A           
  1533                                       .length:       equ  $-semgeterror
  1534 00000154 4552524F522053454D-          semctlerror:   db   "ERROR SEMCTL", 10
  1535 0000015D 43544C0A           
  1536                                       .length:       equ  $-semctlerror
  1537 00000161 63616E6E6F74206765-          ftokerror:     db   "cannot get IPC key from ftok function", 10
  1538 0000016A 7420495043206B6579-
  1539 00000173 2066726F6D2066746F-
  1540 0000017C 6B2066756E6374696F-
  1541 00000185 6E0A               
  1542                                       .length:       equ  $-ftokerror
  1543 00000187 73656D6170686F7265-          initsemerror:  db   "semaphore could not be initialized", 10
  1544 00000190 20636F756C64206E6F-
  1545 00000199 7420626520696E6974-
  1546 000001A2 69616C697A65640A   
  1547                                       .length:       equ  $-initsemerror
  1548 000001AA 73656D206F70657261-          semoperror:    db   "sem operation error", 10
  1549 000001B3 74696F6E206572726F-
  1550 000001BC 720A               
  1551                                       .length:       equ  $-semoperror
  1552 000001BE 507265737320726574-          msglock:       db   "Press return to lock: ", 10
  1553 000001C7 75726E20746F206C6F-
  1554 000001D0 636B3A200A         
  1555                                       .length:       equ  $-msglock
  1556 000001D5 547279696E6720746F-          msgtrylock:    db   "Trying to lock...", 10
  1557 000001DE 206C6F636B2E2E2E0A 
  1558                                       .length:       equ  $-msgtrylock
  1559 000001E7 4C6F636B65642E0A             msglocked:     db   "Locked.", 10
  1560                                       .length:       equ  $-msglocked
  1561 000001EF 507265737320726574-          msgunlock:     db   "Press return to unlock: ", 10
  1562 000001F8 75726E20746F20756E-
  1563 00000201 6C6F636B3A200A     
  1564                                       .length:       equ  $-msgunlock
  1565 00000208 556E6C6F636B65642E-          msgunlocked:   db   "Unlocked.", 10
  1566 00000211 0A                 
  1567                                       .length:       equ  $-msgunlocked
  1568                                       
  1569                                  section .text
  1570                                  global _start:
  1571                                  _start:
  1572                                  
  1573                                       ;sb.sem_num = 0;
  1574                                       ;sb.sem_op = -1;  /* set to allocate resource */
  1575                                       ;sb.sem_flg = SEM_UNDO;
  1576                                  
  1577 00000000 48C70425[B4000000]-          mov       qword[sb.sem_num], 0
  1578 00000008 00000000           
  1579 0000000C 48C70425[BC000000]-          mov       qword[sb.sem_op], -1               ; set to allocate resource
  1580 00000014 FFFFFFFF           
  1581 00000018 48C70425[C4000000]-          mov       qword[sb.sem_flg], SEM_UNDO
  1582 00000020 00100000           
  1583                                      
  1584                                       ;if ((key = ftok("semdemo.c", 'J')) == -1) {
  1585                                       ;   perror("ftok");
  1586                                       ;   exit(1);
  1587                                       ;}
  1588                                  
  1589 00000024 48BF-                        mov       rdi, file                                    ; path to file
  1590 00000026 [3401000000000000] 
  1591 0000002E BE4A000000                   mov       rsi, 'J'                                     ; proj_id
  1592 00000033 E8ED010000                   call      ftok
  1593 00000038 48890425[24010000]           mov       qword[key], rax                              ; save the retrieved key
  1594 00000040 4885C0                       test      rax, rax
  1595 00000043 0F883F010000                 js        error.ftok                                   ; on error just exit, just because we are lazy in this example
  1596                                       
  1597                                       
  1598                                      ;/* grab the semaphore set created by seminit.c: */
  1599                                      ;if ((semid = initsem(key, 1)) == -1) {
  1600                                      ;    perror("initsem");
  1601                                      ;    exit(1);
  1602                                      ;}
  1603                                  
  1604 00000049 488B3C25[24010000]          mov        rdi, qword[key]                                             ; key
  1605 00000051 BE01000000                  mov        rsi, 1                                                      ; nsems
  1606 00000056 E8C9010000                  call       initsem
  1607                                      ; rax holds the semid or a negative value when an error occured
  1608 0000005B 48890425[2C010000]          mov        qword[semid], rax
  1609 00000063 4885C0                      test       rax, rax
  1610 00000066 0F886A010000                js         error.initsem
  1611                                      
  1612                                      ;printf("Press return to lock: ");
  1613                                      ;getchar();
  1614                                      ;printf("Trying to lock...\n");
  1615                                  
  1616 0000006C BA1700000048BE-             syscall write, stdout, msglock, msglock.length
  1617 00000073 [BE01000000000000]-
  1618 0000007B BF01000000B8010000-
  1619 00000084 000F05             
  1620 00000087 E8F7010000                  call        waitforkeypress
  1621 0000008C BA1200000048BE-             syscall     write, stdout, msgtrylock, msgtrylock.length
  1622 00000093 [D501000000000000]-
  1623 0000009B BF01000000B8010000-
  1624 000000A4 000F05             
  1625                                      
  1626                                      ;if (semop(semid, &sb, 1) == -1) {
  1627                                      ;    perror("semop");
  1628                                      ;    exit(1);
  1629                                      ;}
  1630                                      
  1631 000000A7 BA0100000048BE-             syscall   semop, qword[semid], sb, 1
  1632 000000AE [B400000000000000]-
  1633 000000B6 488B3C25[2C010000]-
  1634 000000BE B8410000000F05     
  1635 000000C5 4885C0                      test      rax, rax
  1636 000000C8 0F882F010000                js        error.semop
  1637                                  
  1638                                      ;printf("Locked.\n");
  1639                                      ;printf("Press return to unlock: ");
  1640                                      ;getchar();
  1641                                  
  1642 000000CE BA0800000048BE-             syscall    write, stdout, msglocked, msglocked.length
  1643 000000D5 [E701000000000000]-
  1644 000000DD BF01000000B8010000-
  1645 000000E6 000F05             
  1646 000000E9 BA1900000048BE-             syscall    write, stdout, msgunlock, msgunlock.length
  1647 000000F0 [EF01000000000000]-
  1648 000000F8 BF01000000B8010000-
  1649 00000101 000F05             
  1650 00000104 E87A010000                  call       waitforkeypress
  1651                                      
  1652                                      ;sb.sem_op = 1; /* free resource */
  1653                                      
  1654 00000109 48C70425[BC000000]-         mov   qword[sb.sem_op], 1                ; free resource
  1655 00000111 01000000           
  1656                                      
  1657                                      ;if (semop(semid, &sb, 1) == -1) {
  1658                                      ;    perror("semop");
  1659                                      ;    exit(1);
  1660                                      ;}
  1661                                  
  1662 00000115 BA0100000048BE-             syscall   semop, qword[semid], sb, 1
  1663 0000011C [B400000000000000]-
  1664 00000124 488B3C25[2C010000]-
  1665 0000012C B8410000000F05     
  1666 00000133 4885C0                      test       rax, rax
  1667 00000136 0F88C1000000                js         error.semop
  1668                                  
  1669                                      ; printf("Unlocked\n");
  1670 0000013C BA0A00000048BE-             syscall    write, stdout, msgunlocked, msgunlocked.length
  1671 00000143 [0802000000000000]-
  1672 0000014B BF01000000B8010000-
  1673 00000154 000F05             
  1674                                  
  1675 00000157 4831FFB83C0000000F-         syscall    exit, 0
  1676 00000160 05                 
  1677                                      
  1678                                  error:
  1679                                  .semget:
  1680 00000161 BA1600000048BE-              syscall   write, stderr, semgeterror, semgeterror.length
  1681 00000168 [3E01000000000000]-
  1682 00000170 BF02000000B8010000-
  1683 00000179 000F05             
  1684 0000017C BF01000000B83C0000-          syscall   exit, 1
  1685 00000185 000F05             
  1686                                  .ftok:
  1687 00000188 BA2600000048BE-              syscall   write, stderr, ftokerror, ftokerror.length
  1688 0000018F [6101000000000000]-
  1689 00000197 BF02000000B8010000-
  1690 000001A0 000F05             
  1691 000001A3 BF01000000B83C0000-          syscall   exit, 1
  1692 000001AC 000F05             
  1693                                  .semctl:
  1694 000001AF BA0D00000048BE-              syscall   write, stderr, semctlerror, semctlerror.length
  1695 000001B6 [5401000000000000]-
  1696 000001BE BF02000000B8010000-
  1697 000001C7 000F05             
  1698 000001CA BF01000000B83C0000-          syscall   exit, 1
  1699 000001D3 000F05             
  1700                                  .initsem:
  1701 000001D6 BA2300000048BE-              syscall   write, stderr, initsemerror, initsemerror.length
  1702 000001DD [8701000000000000]-
  1703 000001E5 BF02000000B8010000-
  1704 000001EE 000F05             
  1705 000001F1 BF01000000B83C0000-          syscall   exit, 1
  1706 000001FA 000F05             
  1707                                  .semop:     
  1708 000001FD BA1400000048BE-              syscall   write, stderr, semoperror, semoperror.length
  1709 00000204 [AA01000000000000]-
  1710 0000020C BF02000000B8010000-
  1711 00000215 000F05             
  1712 00000218 BF01000000B83C0000-          syscall   exit, 1
  1713 00000221 000F05             
  1714                                  
  1715                                  
  1716                                  initsem:
  1717                                    ; rdi = key (from ftok)
  1718                                    ; rsi = nsems
  1719 00000224 C3                          ret
  1720                                      
  1721                                  %ifdef REMARK    
  1722                                  
  1723                                  
  1724                                  
  1725                                  ; initsem() -- more-than-inspired by W. Richard Stevens' UNIX Network
  1726                                  ; Programming 2nd edition, volume 2, lockvsem.c, page 295.
  1727                                  
  1728                                  int initsem(key_t key, int nsems)  /* key from ftok() */
  1729                                  {
  1730                                      int i;
  1731                                      union semun arg;
  1732                                      struct semid_ds buf;
  1733                                      struct sembuf sb;
  1734                                      int semid;
  1735                                  
  1736                                      semid = semget(key, nsems, IPC_CREAT | IPC_EXCL | 0666);
  1737                                  
  1738                                      if (semid >= 0) { /* we got it first */
  1739                                          sb.sem_op = 1; sb.sem_flg = 0;
  1740                                          arg.val = 1;
  1741                                  
  1742                                          printf("press return\n"); getchar();
  1743                                  
  1744                                          for(sb.sem_num = 0; sb.sem_num < nsems; sb.sem_num++) { 
  1745                                              /* do a semop() to "free" the semaphores. */
  1746                                              /* this sets the sem_otime field, as needed below. */
  1747                                              if (semop(semid, &sb, 1) == -1) {
  1748                                                  int e = errno;
  1749                                                  semctl(semid, 0, IPC_RMID); /* clean up */
  1750                                                  errno = e;
  1751                                                  return -1; /* error, check errno */
  1752                                              }
  1753                                          }
  1754                                  
  1755                                      } else if (errno == EEXIST) { /* someone else got it first */
  1756                                          int ready = 0;
  1757                                  
  1758                                          semid = semget(key, nsems, 0); /* get the id */
  1759                                          if (semid < 0) return semid; /* error, check errno */
  1760                                  
  1761                                          /* wait for other process to initialize the semaphore: */
  1762                                          arg.buf = &buf;
  1763                                          for(i = 0; i < MAX_RETRIES && !ready; i++) {
  1764                                              semctl(semid, nsems-1, IPC_STAT, arg);
  1765                                              if (arg.buf->sem_otime != 0) {
  1766                                                  ready = 1;
  1767                                              } else {
  1768                                                  sleep(1);
  1769                                              }
  1770                                          }
  1771                                          if (!ready) {
  1772                                              errno = ETIME;
  1773                                              return -1;
  1774                                          }
  1775                                      } else {
  1776                                          return semid; /* error, check errno */
  1777                                      }
  1778                                  
  1779                                      return semid;
  1780                                  }     
  1781                                  
  1782                                  %endif
  1783                                  
  1784                                  ftok:
  1785                                       ; source: http://beej.us/guide/bgipc/output/html/multipage/mq.html
  1786                                       ; the type key_t is actually just a long, you can use any number you want. But what if you hard-code the number and some other unrelated
  1787                                       ; program hardcodes the same number but wants another queue? The solution is to use the ftok() function which generates a key from two arguments:
  1788                                       ; key_t ftok(const char *path, int id);
  1789                                       ;
  1790                                       ; RDI has the path/file string to the file
  1791                                       ; RSI has an 'project id' arbitrary choosen.
  1792                                       ; on return: RAX has a unique key
  1793                                       ; on failure: RAX = a negative number containing the error
  1794                                       ; key = ((st.st_ino & 0xffff) | ((st.st_dev & 0xff) << 16) | ((proj_id & 0xff) << 24));
  1795                                  
  1796                                       ; save the project id in R8 (will remain after syscalls)
  1797                                  
  1798 00000225 4989F0                       mov       r8, rsi
  1799                                       ; open the file
  1800 00000228 4831F6B8020000000F-          syscall   open, rdi, O_RDONLY
  1801 00000231 05                 
  1802 00000232 4821C0                       and       rax, rax
  1803 00000235 784B                         js        .done
  1804 00000237 48BE-                        syscall   fstat, rax, stat
  1805 00000239 [0000000000000000]-
  1806 00000241 4889C7B8050000000F-
  1807 0000024A 05                 
  1808 0000024B 4821C0                       and       rax, rax
  1809 0000024E 7832                         js        .done
  1810 00000250 488B0425[08000000]           mov       rax, QWORD [stat.st_ino]                ; get the file size
  1811 00000258 4825FFFF0000                 and       rax, 0xFFFF
  1812 0000025E 488B1C25[00000000]           mov       rbx, QWORD [stat.st_dev]
  1813 00000266 4881E3FF000000               and       rbx, 0xFF
  1814 0000026D 48C1E310                     shl       rbx, 16
  1815 00000271 4809D8                       or        rax, rbx
  1816 00000274 4981E0FF000000               and       r8, 0xFF                                ; R8 = proj_id
  1817 0000027B 49C1E018                     shl       r8, 24
  1818 0000027F 4C09C0                       or        rax, r8
  1819                                       ; rax now contains a key which uniquely identifies the file.
  1820                                  .done:     
  1821 00000282 C3                           ret
  1822                                  
  1823                                       
  1824                                  ; Name:         waitforkeypress
  1825                                  
  1826                                  waitforkeypress:
  1827                                  
  1828 00000283 E842000000                  call    TermIOS.Canonical.OFF      ; switch canonical mode off
  1829 00000288 E84B000000                  call    TermIOS.Echo.OFF           ; no echo
  1830                                  
  1831                                  .readKey:
  1832 0000028D BA0100000048BE-             syscall read, STDIN, keybuffer, 1
  1833 00000294 [0000000000000000]-
  1834 0000029C 4831FFB8000000000F-
  1835 000002A5 05                 
  1836 000002A6 8A0425[00000000]            mov     al, byte[keybuffer]
  1837 000002AD 3C0A                        cmp     al, 10
  1838 000002AF 75DC                        jne     .readKey
  1839                                      
  1840                                      ; clear the buffer
  1841 000002B1 48C7060A000000              mov     QWORD[rsi], 10
  1842                                  
  1843                                      ; Don't forget to switch canonical mode on
  1844 000002B8 E806000000                  call    TermIOS.Canonical.ON       ; switch canonical mode back on
  1845 000002BD E80F000000                  call    TermIOS.Echo.ON            ; restore echo
  1846 000002C2 C3                          ret
  1847                                      
  1848                                  TermIOS.Canonical:
  1849                                  .ON:
  1850 000002C3 B802000000                  mov     rax, ICANON
  1851 000002C8 EB15                        jmp     TermIOS.LocalModeFlag.SET
  1852                                  
  1853                                  .OFF:
  1854 000002CA B802000000                  mov     rax,ICANON
  1855 000002CF EB20                        jmp     TermIOS.LocalModeFlag.CLEAR
  1856                                  
  1857                                  TermIOS.Echo:
  1858                                  .ON:
  1859 000002D1 B80A000000                  mov     rax,ECHO
  1860 000002D6 EB07                        jmp     TermIOS.LocalModeFlag.SET
  1861                                  
  1862                                  .OFF:
  1863 000002D8 B80A000000                  mov     rax,ECHO
  1864 000002DD EB12                        jmp     TermIOS.LocalModeFlag.CLEAR
  1865                                  
  1866                                  TermIOS.LocalModeFlag:
  1867                                  .SET:
  1868 000002DF E821000000                  call    TermIOS.STDIN.READ
  1869 000002E4 090425[9C000000]            or      dword [termios.c_lflag], eax
  1870 000002EB E81C000000                  call    TermIOS.STDIN.WRITE
  1871 000002F0 C3                          ret
  1872                                  
  1873                                  .CLEAR:
  1874 000002F1 E80F000000                  call    TermIOS.STDIN.READ
  1875 000002F6 F7D0                        not     eax
  1876 000002F8 210425[9C000000]            and     [termios.c_lflag], eax
  1877 000002FF E808000000                  call    TermIOS.STDIN.WRITE
  1878 00000304 C3                          ret
  1879                                  
  1880                                  ; subroutine for all TCGETS operation on the syscall IOCTL
  1881                                  ; the original value of RCX is restored on exit
  1882                                  TermIOS.STDIN:
  1883                                  .READ:
  1884 00000305 BE01540000                  mov     rsi, TCGETS
  1885 0000030A EB05                        jmp     TermIOS.IOCTL
  1886                                  
  1887                                  ; subroutine for all TCSETS operation on the syscall IOCTL
  1888                                  ; the original value of RCX is restored on exit
  1889                                  .WRITE:
  1890 0000030C BE02540000                  mov     rsi, TCSETS
  1891                                  
  1892                                  ; subroutine for operations on the syscall IOCTL for STDIN
  1893                                  ; all registers are restored to their original values on exit of the subroutine
  1894                                  TermIOS.IOCTL:
  1895 00000311 50                          push    rax             ; we need to store RAX or TermIOS.LocalFlag functions fail
  1896 00000312 48BA-                       syscall ioctl, STDIN, rsi, termios
  1897 00000314 [9000000000000000]-
  1898 0000031C 4831FFB8100000000F-
  1899 00000325 05                 
  1900 00000326 58                          pop     rax
  1901 00000327 C3                          ret     
